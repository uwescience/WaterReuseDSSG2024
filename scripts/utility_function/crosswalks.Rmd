---
title: "crosswalks"
output: html_document
date: "2024-07-08"
---

## General notes on crosswalks
Crosswalks are needed to align geospatial data that are on different scales. Scales here are referring to units of analysis (county, census tracts, blocks, watershed etc.) While it is easy to aggregate datasets when the sum of the parts equal the whole, it is not always the case. This script generates steps for crosswalks that allow us compare variables in a different resolution. 

Crosswalks can be helpful in two scenarios First, there should be crosswalk between different spatial resolution in the same time period. Second, crosswalk can be helpful when the boundary of the spatial resolution changes over time. There should be an estimated population or any features for newly demarcated boundary. 

We focus on the first type of problem - same year, but different resolutions. There are two ways of resolving this problem.
1) Downward approach
- Assignment Borrowing: Let's say for example we have a dataset at a county-level. Each row of this dataset contains a binary variable telling us whether or not that county has Republican partisanship. If we want this data to talk to the census-tract level data, we can automatically let this information flow downstream by simply coding *all* of the census-tract within the county as 1. (And census tracts always fall under the county.)
- Aportioning: Another option is to use weighting. For example, let's say King County is 50% Seattle, 20% Kirkland and 30% Bellevue. Our county-level data tells us that there are 10 elementary schools in the entire King County. Given the information about city distribution within the King County, we can estimate the number of elementary schools within each city. By using this weighting (usually population), we're allowing county-level and city-level data speak to each other. 

2) Upward approach
- Aggregate: We can simply add up the components to fill in the information at the higher level. For example, by adding up the number of students across all of the departments on campus, we get the total number of students. 
- Population Weighting: Even if we have information for a subset of data at the low level, we can estimate the value for the total by weighting. Note that [IPUMS](https://www.nhgis.org/geographic-crosswalks) discusses these two approaches more extensively.

## Weighting and Aportioning
*Where to find weighting values*
Either way, it's important to find the relevant weighting values. [MCDC](https://mcdc.missouri.edu/applications/geocorr2022.html) provides these weights. Select source scale and target scale for states of interest. This will generate a .csv file that contains crosswalk weights. Users should download their own weight dataset of interest. 

Geographic level codes:
    tr  - Census tract
    co  - County
    

## Overlay county-level data *onto* census tracts map
```{r}
library(readxl)
library(tidycensus)
library(tigris)
options(tigris_use_cache = TRUE)
library(tidyverse)
library(data.table)
library(dplyr)
library(roxygen2)


crosswalk_data <- function(data, 
                           source_scale, 
                           key, 
                           target_scale) {
  #' Append index column for crosswalks
  #' 
  #' @description
  #' 'crosswalk_data' returns dataframe with geo-spatial labels appended
  #' 
  #' @param data raw data that needs to be converted to a different scale
  #' @param source_scale Character vector. column that contains scale information. 
  #' @param key Character vector. formal name of the source scale according to the Census GeoID
  #'  "tract.census.geoid"        
  #'  "county.census.geoid"       
  #'  "puma.census.geoid"        
  #'  "state.census.geoid"      
  #'  "state.census.name"         
  #'  "metro.census.cbsa10.geoid" 
  #'  "metro.census.cbsa10.name"  
  #'  "metro.census.csa10.geoid" 
  #'  "metro.census.csa10.name"   
  #'  "region.woodard.nation"     
  #'  "region.woodard.culture"    
  #'  "region.census.main"      
  #'  "region.census.division"
  #' @param target_scale Character vector. formal name of the target scale. Scale which the data needs to be converted to.
  #'
  #' @examples
  #' drought_intermediary 
  #' <- crosswalk_data(drought, source_scale = "county_fips", key = "county.census.geoid", target_scale = "tract.census.geoid")
  #' 
  
  if (!is.character(data[[source_scale]])) {
    data <- data %>%
      mutate({{ source_scale }} := as.character({{ source_scale }}))
  }
  
  tracts_url <- "https://nccsdata.s3.us-east-1.amazonaws.com/geo/xwalk/TRACTX.csv"
  crosswalk_file <- readr::read_csv(tracts_url)
  
  merged_data <- data %>%
    left_join(crosswalk_file, by = setNames(key, source_scale))
  
  merged_data <- as.data.frame(merged_data) %>%
    select(-source_scale)
  
  
  return(merged_data)
}

```

# Merging with crosswalk weights data
Refer to the [MCDC](https://mcdc.missouri.edu/applications/geocorr2022.html) for additional weights data of interest. This script is only for data from county to census tracts, based on population and area weights. Below function is only for crosswalks between census tract and county. 

```{r}
ct_tr_population <- read.csv("../data/2020ct_tr.csv", header = T)[-1,] 
ct_tr_area <- read.csv("../data/2020ct_tr_area.csv", header = T)[-1,] 
tr_ct_population <- read.csv("../data/2020tr_ct.csv", header = T)[-1,]
tr_ct_area <- read.csv("../data/2020tr_ct_area.csv", header = T)[-1,]

library(dplyr)

process_data <- function(data) {
  data$tract <- gsub("\\.", "", data$tract)
  processed_data <- data %>%
    mutate(afact = as.numeric(afact)) %>%
    mutate(tract.census.geoid = paste0(county, tract)) %>%
    rename(county.census.geoid = county)
  
  return(processed_data)
}

ct_tr_area <- process_data(ct_tr_area)
ct_tr_population <- process_data(ct_tr_population)
tr_ct_population <- process_data(tr_ct_population)
tr_ct_area <- process_data(tr_ct_area)


```

Once we find the corresponding weights data, the next step is to merge/join these weights with the source data and transform (multiply) them into values that align with the target data.

# test1 : county to census tract
```{r}
# read in data sets
drought <- read_excel("../data/final_results_dissemination_NDINDC.xlsx")
drought$county_fips <- as.character(drought$FIPS)
drought_intermediary <- crosswalk_data(drought,
                                       source_scale = "county_fips",
                                       key = "county.census.geoid",
                                       target_scale = "tract.census.geoid")

```

#test2 : census tract to county
```{r}
cvi <- cvi %>% 
  rename("tract_fips" = "FIPS Code")

cvi_intermediary <- crosswalk_data(data = cvi,
                          source_scale = "tract_fips",
                          key = "tract.census.geoid",
                          target_scale = "county.census.geoid")

cvi_intermediary <- as.data.frame(cvi_intermediary) 

```

#test3: county to tract and add weights
```{r}
ct_tr_population <- ct_tr_population %>%
  mutate(tract.census.geoid = paste0(county, tract))

# attach weights and interpolate census tract level data
drought_final <- drought_intermediary %>%
  dplyr::left_join(ct_tr_population, by = "tract.census.geoid")


```


#functions that attach weights to labels

##County to tract 
This will take the output of crosswalk_data function as an input.
```{r}
county_tract <- function(data, weight_type, variable, weight, calc_method){
#input: data frame containing ID column 
  if (!is.data.frame(data)) {
    stop("Input 'data' must be a dataframe.")
  }
  
  if (weight_type == "population") {
    data <- data %>%
      left_join(ct_tr_population, by = "tract.census.geoid")
  }
  if (weight_type == "area") {
    data <- data %>%
      left_join(ct_tr_area, by = "tract.census.geoid")
  }
  if (tolower(calc_method) == "weighted_mean") {
  processed_data <- data %>%
    group_by(tract.census.geoid) %>%
    mutate(!!paste0(variable, "_weighted") := weighted.mean(!!sym(variable), !!sym(weight), na.rm = TRUE))
  } 
  else if (tolower(calc_method) == "weighted_sum") {
  processed_data <- data %>%
    group_by(tract.census.geoid) %>%
    mutate(!!paste0(variable, "_sum") := sum(!!sym(variable) * !!sym(weight), na.rm = TRUE))
  } 
  else if (tolower(calc_method) == "sum") {
  processed_data <- data %>%
    group_by(tract.census.geoid) %>%
    mutate(!!paste0(variable, "_sum") := sum(!!sym(variable), na.rm = TRUE))
  } 
  
  else {
  stop("Invalid value for 'calc_method'. Please specify either 'weighted_mean', 'weighted_sum', or 'sum'.")
  }

  return(processed_data)
  
}

county_tract(drought_intermediary, "population", "NDI", "afact", "weighted_mean")
  
```
## Tract to county
```{r}
tract_county <- function(data, weight_type, variable, weight, calc_method) {
  if (is.data.frame(data)) {
    data <- data %>%
      select( "county.census.geoid", {{ variable }})
  }
  if (!is.data.frame(data)) {
    stop("Input 'data' must be a dataframe.")
  }
  
  if (weight_type == "population") {
    data <- data %>%
      left_join(tr_ct_population, by = "county.census.geoid")
  } else if (weight_type == "area") {
    data <- data %>%
      left_join(tr_ct_area, by = "county.census.geoid")
  } else {
    stop("Invalid value for 'weight_type'. Please specify either 'population' or 'area'.")
  }
  
  print(head(data))
  if (tolower(calc_method) == "weighted_mean") {
    processed_data <- data %>%
      group_by(county.census.geoid) %>%
      summarize(!!paste0(variable, "_weighted") := weighted.mean(!!sym(variable), !!sym(weight), na.rm = TRUE))
  } else if (tolower(calc_method) == "weighted_sum") {
    processed_data <- data %>%
      group_by(county.census.geoid) %>%
      summarize(!!paste0(variable, "_sum") := sum(!!sym(variable) * !!sym(weight), na.rm = TRUE))
  } else if (tolower(calc_method) == "sum") {
    processed_data <- data %>%
      group_by(county.census.geoid) %>%
      summarize(!!paste0(variable, "_sum") := sum(!!sym(variable), na.rm = TRUE))
  } else {
    stop("Invalid value for 'calc_method'. Please specify either 'weighted_mean', 'weighted_sum', or 'sum'.")
  }

  return(processed_data)
}

# Example usage:
sample2 <- tract_county(cvi_intermediary, "area", "CVI_overall", "afact", "weighted_mean")


```


