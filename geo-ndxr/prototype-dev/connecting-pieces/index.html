<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>My Map</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>

</head>

<body>
    <h1 id="page-title">My Map</h1>
    <div class="content">
        <div class="sidebar">
            <div id="checkbox-menu"></div>
            <button id="submit-button" disabled>Submit</button>
            <button id="download-button" disabled>Download</button>
            <div>
                <h1 id="loading">Loading, please wait...</h1>
                <pre><code id="out"></code></pre>
            </div>
            <button id="recalc" disabled>Recalculating...</button>

        </div>
        <div>

            <div id="map" class="leaflet html-widget html-fill-item"></div>
        </div>
    </div>
    <div id="description">{Description placeholder}</div>

    <script src="scripts.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            createCheckboxes();
        });

        async function loadAndPlotMap(jsonPath, indexKey) {
            try {
                const response = await fetch(jsonPath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const geoJsonData = await response.json();
                plot_map(geoJsonData, indexKey, latitude, longitude, zoomLevel);
            } catch (error) {
                console.error('Error loading the GeoJSON file:', error);
            }
        }
        // Call the function with the path to your GeoJSON file and the index key to use

        ///NEEDS TO BE CHANGED TO PLOT THE RIGHT THING
        //loadAndPlotMap(map_data_path, initial_index);
    </script>
    <script src="https://webr.r-wasm.org/latest/webr.mjs" type="module"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>

    <!-- <script src="mount.js" type="module"></script> -->
    <script type="module">
        import { WebR } from 'https://webr.r-wasm.org/latest/webr.mjs';
        const webr = new WebR();
        await webr.init();
        

        // Download a filesystem image
        await webr.FS.mkdir('/data')
        const data = await fetch('./output.data');
        const metadata = await fetch('./output.js.metadata');

        // Mount the filesystem image data
        const options = {
            packages: [{
                blob: await data.blob(),
                metadata: await metadata.json(),
            }],
        }
        await webr.FS.mount("WORKERFS", options, '/data');

        // Read the contents of the map
        const result = await webr.evalR('readLines("/data/abc.geojson")');
        loadAndPlotMap('./output.data', "index_value");

        await webr.installPackages(["dplyr", "tidyr", "jsonlite", "sf", "geojsonsf"]);

        document.getElementById('loading').remove();
        
        const output = await result.toArray();
        const text = output.join('\n');

        // source dependencies for the R script below
        const pcaWeightsPath = "./scripts/get_pca_weights.R";
        const weightedAvgPath = "./scripts/weighted_average.R";
        const selectVarsPath = "./scripts/select_vars.R";

        const fetchText = async (filePath) => {
            const response = await fetch(filePath);
            return await response.text();
        };

        console.log("Sourcing R functions...");

        let pcaResponse = await fetch(pcaWeightsPath);
        let pcaText = await pcaResponse.text();
        await webr.evalR(pcaText);

        let weightedAvgResponse = await fetch(weightedAvgPath);
        let weightedAvgText = await weightedAvgResponse.text();
        await webr.evalR(weightedAvgText);

        let selectVars = await fetch(selectVarsPath);
        let selectVarsText = await selectVars.text();
        await webr.evalR(selectVarsText);

        console.log("R functions sourced");

        console.log("Fetching map data...");
        const geoJsonResponse = await fetch(map_data_path);
        const geoJsonData = await geoJsonResponse.json();

        const geoJsonDataString = JSON.stringify(geoJsonData);

        console.log("Data fetched");

        document.getElementById('submit-button').disabled = false

        async function recalculate() {
            document.getElementById('recalc').disabled = false;
            const selectedOptions = [];
            const checkboxes = document.querySelectorAll('#checkbox-menu input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedOptions.push(checkbox.name);
                }
            });

            const selectedOptionsString = JSON.stringify(selectedOptions);
            console.log(selectedOptionsString)

            let scriptText = `
                library(dplyr)
                library(jsonlite)
                library(sf)
                library(geojsonsf)
                library(tidyr)

                ####We can get the data in, but it doesn't read well as a geojson. Maybe a csv or some such plain text file will work

                test <- '${text}'
                print(test)

                sf <- geojson_sf(test)

                cols_to_keep <- fromJSON('${selectedOptionsString}')
                cols_to_keep <- cols_to_keep[-which(cols_to_keep=="")]

                cols_to_keep <- as.array(cols_to_keep)
                sf_filtered <- filter_data(sf, cols_to_keep)

                weights <- get_pca_weights(data = sf_filtered, excluded_cols = c("geometry"))

                index <- get_weighted_average(sf_filtered, weights, excluded_cols = c("geometry"))

                sf <- cbind(sf, index)

                geo_index <- sf_geojson(sf)

                output <- toJSON(geo_index)

                return(geo_index)
                `;

            const result = await webr.evalR(scriptText);
            const resultJson = JSON.parse((await result.toJs()).values);

            plot_map(resultJson, "index", latitude, longitude, zoomLevel);

            // Enable the download button
            document.getElementById('download-button').disabled = false;

            document.getElementById('download-button').addEventListener('click', function() {
            
            const jsonString = JSON.stringify(resultJson);

            // Create a blob with JSON data
            const blob = new Blob([jsonString], { type: 'application/json' });

            // Create a link element
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'recalc_output.geojson'; // Specify the file name

            // Trigger the download
            link.click();

            // Clean up the URL object
            URL.revokeObjectURL(link.href);
        });
        document.getElementById('recalc').disabled = true;
        }
        document.getElementById('submit-button').addEventListener('click', recalculate);

    </script>
    </script>
</body>

</html>