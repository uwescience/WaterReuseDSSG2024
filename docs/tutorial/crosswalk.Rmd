---
output: github_document
date: "2024-07-30"
---

```{r}
#| include = FALSE
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  message = FALSE
)
suppressPackageStartupMessages(library(ggplot2))
theme_set(theme_light())
```

# Crosswalk: tools for web creators

Crosswalks are needed to align geospatial data that are on different scales. Scales here are referring to units of analysis (county, census tracts, blocks, watershed etc.) 

To analyze datasets at different geospatial resolutions, pre-processing steps should take place to ensure aggregation (low-to-high resolution) and splitting ( high-to-low) are done smoothly. With the goal of helping web creators process their data sets, we provide functions and supporting data sets to allow crosswalks across nested and un-nested spatial units.




### Installation

Make sure you edit the ["config.yml" file]("~/config.yml") and replace the template with your home directory path.

```{r eval = TRUE, warning = FALSE}


config::get()
library(dplyr)
library(docstring)
library(readr)
```

### Crosswalk id example: the `crosswalk_id` function

National Drought Index [dataset] is at county level. Each row gives information about county, in FIPS code. For more details about the FIPS code, refer to the census bureau [website](https://www.census.gov/library/reference/code-lists/ansi/ansi-codes-for-states.html).

```{r}
root_dir <- config::get()
ndi <- read_csv(paste0(root_dir,"/data/drought_risk.csv"))
```

The `crosswalk_id` function will append a list of additional IDs including census tracts and states, for each county. You have to tell the function what your data's geospatial resolution is. For example, by setting `source_scale = "FIPS"` and `key = "county.census.geoid"`, you are telling the `crosswalk_id()` function that your column "FIPS" is county code. Geospatial level of your source_scale and key should match. 
```{r}
source(paste0(root_dir, "/code/crosswalk/crosswalk_id.R"))

processed_data <- crosswalk_id(data=ndi,  
                               data2=NULL, 
                               source_scale = "FIPS",
                               key = "county.census.geoid")

head(processed_data)
names(processed_data) 
```
You will see a list of new id columns appended to each county-level observation. This set of census-related columns will be provided to users as a *default*. However, you can specify an external reference table for ID crosswalk by specifying `data2=NULL`. If your data and data2 contain a lot of columns and hence if it is hard to manually check a list of variables that exist in both data sets, refer to `identify_key()` helpfer function. 

### Crosswalk with weights dataset: `apply_weight` function

Let's use [Climate Vulnerabilitly Index (CVI) data](https://climatevulnerabilityindex.org) as an example for this function. 
```{r}
library(readr)
cvi <- read_csv(paste0(root_dir, "/data/CVI Data Excerpts_rename.csv"))
head(cvi)
```
Note that the unit of cvi dataset is census tract. Our goal is to walk census tract level to county (upward). 
-   Aggregation: We can simply add up the components to fill in the information at the higher level. For example, by adding up the number of CVI across all of the census tracts, we get the total number for county.
-   Weighting: Even if we have information for a subset of data at the low level, we can estimate the value for the total by weighting. Note that [IPUMS](https://www.nhgis.org/geographic-crosswalks) discusses these two approaches more extensively.

```{r}
cvi_appended <- crosswalk_id(cvi, 
                             data2 = NULL,
                             source_scale = "FIPS Code",
                             key = "tract.census.geoid")
head(cvi_appended)
            
```

Now that we have a dataframe with a bunch of identifiable ID columns, we can aggregate/split in many different directions. During this process, we might have to source population weighting data. [MCDC](https://mcdc.missouri.edu/applications/geocorr2022.html) provides these weights. Select source scale and target scale for states of interest. This will generate a .csv file that contains crosswalk weights. Users should download their own weight datasets of interest.

```{r}
root_dir <- config::get()
source(paste0(root_dir,"/code/crosswalk/apply_weight.R"))

weight_data <- read.csv(paste0(root_dir, "/code/crosswalk/weights_data/2020tr_ct_area.csv"))

cvi_aggregated <- cvi_appended %>%
  apply_weight(source_scale = "FIPS Code",
               weight_data = weight_data,
               key = "tract.census.geoid",
               variable = c("CVI_Overall", "CVI_base_all"),
               method = "sum",
               weight_value = "afact")
```



### Census crosswalks as default: `crosswalk_census` function
####   ⬆️ Upward crosswalk: CVI example
While you can provide your own weight_data by using `apply_weight()` function, we provide a default dataset to allow easy aggregation and splitting across three mostly-used resolutions: *census tract, county, and Public Use Microdata Area (PUMA).*

```{r}
source(paste0(root_dir,"/code/crosswalk/crosswalk_census.R"))
docstring(crosswalk_census)

cvi_county <- cvi %>%
  crosswalk_census(key = "tract.census.geoid",
                   source_scale = "FIPS Code",
                   target_scale = "county.census.geoid",
                   weight_by = "area",
                   method = "weighted_mean",
                   variable = c("CVI_overall", "CVI_base_all"))
head(cvi_county)
print(dim(cvi_county))
```
The function `crosswalk_census` will print out the intermediary dataframe where `left_join` of data and embedded weight data happens. The final output dataframe, "cvi_county" has the right number of rows (3087), where each row corresponds to county.

####  ⬇️ Downward crosswalk: NDI example
In the previous example, we used NDI dataset - at county level. Using `crosswalk_census()` function, we can aportion county-level value downwards to the census tract level. If we want this data to talk to the census-tract level data, we can automatically let all of the census-tracts to inherit that value from the upstream. (And census tracts *always* fall under the county.) Assignment borrowing or inheritance is appropriate in cases where the values at the higher level are not shared or distributed down to lower levels.

But for the sake of this tutorial, let's assume that we want to split county-level value into multiple census tracts. In case of downward crosswalk, only `method = "weighted_sum"` makes sense since downward aportioning is relevant to inverse weighting. The other options (mean, sum, weighted_mean) would simply return higher-resolution values. 

```{r}
ndi_reduced <- ndi %>%
  crosswalk_census(source_scale = "FIPS",
                   key = "county.census.geoid",
                   target_scale = "tract.census.geoid",
                   weight_by = "area",
                   method = "weighted_sum",
                   variable = c("NDI", "NDC")
                   )

head(ndi_reduced)
```
### Unnested crosswalk: `crosswalk_spatial`
All of the functions above are useful for handling nested dataset. We further allow users to crosswalk un-nested datasets by using spatial_joins. 

#### example
```{r}
source(paste0(root_dir, "/code/crosswalk/crosswalk_spatial.R"))


```

### Unnested crosswalk: `crosswalk_raster`
All of the functions above are useful for handling nested dataset. We further allow users to crosswalk un-nested datasets by using spatial_joins. 

#### example
```{r}
source(paste0(root_dir, "/code/crosswalk/crosswalk_raster.R"))


```

### Unnested crosswalk: `crosswalk_geom`
All of the functions above are useful for handling nested dataset. We further allow users to crosswalk un-nested datasets by using spatial_joins. 

#### Watershed to county
```{r eval = FALSE}
source(paste0(root_dir, "/code/crosswalk/crosswalk_geom.R"))

aquifers <- st_read(paste0(root_dir,"data/aquifers_us/us_aquifers.shp"))
head(aquifers)

aquifers <- st_transform(aquifers, crs = st_crs(counties_sf))
aquifers <- st_make_valid(aquifers)

joined_sfs <- crosswalk_geom(aquifers, counties_sf)
head(joined_sfs)

```


